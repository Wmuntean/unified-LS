# ====================================================================
# Author: William Muntean
# Copyright (C) 2025 William Muntean. All rights reserved.
#
# Licensed under the GPL v3 License;
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://opensource.org/licenses/GPL v3
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ====================================================================

"""
=======================================================
build_reqs.py
=======================================================

This module provides functionality to generate a ``requirements.txt`` file using pigar,
create an ``environment.yml`` file for conda environments, and update the ``pyproject.toml``
with the correct dependencies and Python version constraints.

Dependency and Environment File Generation
==========================================

The requirements and environment setup is performed in the following stages:

1. **Initialization**:

   - Parse command-line arguments to determine whether to use pigar and/or poetry.
   - Identify the project root and relevant file paths.

2. **Requirements Generation**:

   - Optionally run pigar to generate ``requirements.txt``.
   - Parse the requirements file and extract dependencies.

3. **Environment and Project File Update**:

   - Write a new ``environment.yml`` with pip dependencies.
   - Update ``pyproject.toml`` with Python constraints and dependencies.
   - Optionally use poetry to add dependencies and export exact requirements.

.. Note::
    - This script expects ``requirements.txt`` to exist or be generated by pigar.
    - The script must be run from the ``doc_src/source`` directory or adjust the project root accordingly.

.. Important::
    - Ensure that ``pigar`` and ``poetry`` are installed if their features are used.
    - Review the generated ``requirements.txt`` before proceeding.

.. currentmodule:: build_reqs

Functions
=========

.. autosummary::
    :toctree: generated/
    :nosignatures:
    :template: function_name_only.rst

    main

Standalone Execution
=====================

When run as a standalone script, this module processes the current project's dependencies,
generates ``requirements.txt`` (optionally), creates ``environment.yml``, and updates ``pyproject.toml``.

- Output Files:
    - ``requirements.txt``
    - ``environment.yml``
    - ``pyproject.toml``

.. Note::
   The following paths must be correctly set within the script's ``__main__`` block for successful
   execution:

   - ``project_root``: Defines the root directory of the project.

.. code-block:: bash

    python build_reqs.py

"""

__author__ = "William Muntean"
__email__ = "williamjmuntean@gmail.com"
__license__ = "GPL v3"
__maintainer__ = "William Muntean"
__date__ = "2024-01-23"

import re
import subprocess
from pathlib import Path

import questionary
import tomlkit


def validate_python_version(text: str) -> bool | str:
    """
    Validate that the Python version string is in the form ``X.Y`` or ``X.Y.Z``.

    Parameters
    ----------
    text : str
        The version string to validate.

    Returns
    -------
    bool | str
        True if valid, error message string if invalid.

    Examples
    --------
    >>> validate_python_version("3.10")
    True
    >>> validate_python_version("3.10.2")
    True
    >>> validate_python_version("3")
    'Python version must be in the form X.Y or X.Y.Z, e.g. 3.10 or 3.10.2'
    """
    if not re.match(r"^\d+\.\d+(\.\d+)?$", text):
        return "Python version must be in the form X.Y or X.Y.Z, e.g. 3.10 or 3.10.2"
    return True


def main() -> None:
    """
    Generate environment.yml and update pyproject.toml based on user input.

    This function presents an interactive questionary interface to gather user preferences,
    then generates the necessary configuration files.

    Returns
    -------
    None
        This function does not return a value.

    .. Note::
        This script expects ``requirements.txt`` to exist or be generated by pigar.

    .. Warning::
        Ensure that ``pigar`` and ``poetry`` are installed if those features are selected.
    """
    questionary.print(
        "\n=== Build Requirements Configuration ===\n", style="bold fg:cyan"
    )

    use_pigar = questionary.confirm(
        "Run pigar to create the requirements.txt file?", default=False
    ).ask()

    use_poetry = questionary.confirm(
        "Add dependencies with Poetry?", default=False
    ).ask()

    min_python = questionary.text(
        "Minimum Python version to support:",
        default="3.11",
        validate=validate_python_version,
    ).ask()

    version_parts = min_python.split(".")
    python_major_minor = f"{version_parts[0]}.{version_parts[1]}"

    # Set Python version constraint for pyproject.toml
    python_constraint = f">={min_python},<4.0"

    # Project root
    project_root = Path.cwd().parent.resolve()
    print(f"Using project root: {project_root}")

    req_file = project_root / "requirements.txt"
    env_file = project_root / "environment.yml"
    poetry_file = project_root / "pyproject.toml"

    # Get project name from pyproject
    with open(poetry_file, "r", encoding="utf-8") as f:
        toml_data = tomlkit.load(f)

    project_name = toml_data.get("project", {}).get("name") or toml_data.get(
        "tool", {}
    ).get("poetry", {}).get("name", "your-project-name")

    # Run pigar if requested
    if use_pigar:
        subprocess.run(
            ["pigar", "gen", "-f", str(req_file)], check=True, cwd=project_root
        )
        questionary.press_any_key_to_continue(
            "Review `requirements.txt` before continuing."
        ).ask()

    # Parse requirements.txt
    if not req_file.exists():
        raise FileNotFoundError(f"`requirements.txt` not found at {req_file}")

    with open(req_file, "r") as f:
        requirements = f.readlines()

    pip_dependencies = []
    for line in requirements:
        match = re.match(r"([\w\-.]+)([=<>!~]*[\d\w\.\*]*)", line.strip())
        if match:
            package, version = match.groups()
            match = re.search(r"[=<>!~]+([\w\.\-]+)", version)
            if match:
                version = match.group(1)
                dep = f"{package}~={'.'.join(version.split('.')[:2])}"
            else:
                version = "0.0.0"
                dep = f"{package}>{version}"
                print(
                    f"Warning: No version found for package '{package}'. Using default version '{version}'."
                )
            pip_dependencies.append(dep)

    # Write environment.yml
    yml_content = [
        f"name: {project_name}",
        "channels:",
        "  - conda-forge",
        "  - defaults",
        "dependencies:",
    ]
    # Use exact version if patch was provided, otherwise use wildcard for patch
    if len(version_parts) == 3:
        # X.Y.Z format - use exact version
        yml_content.append(f"  - python={min_python}")
    else:
        # X.Y format - use wildcard for patch
        yml_content.append(f"  - python={python_major_minor}.*")

    yml_content.extend(
        [
            "  - pip",
            "  - pip:",
        ]
    )
    yml_content.extend(f"    - {dep}" for dep in pip_dependencies)
    with open(env_file, "w") as f:
        f.write("\n".join(yml_content))
    print(f"`environment.yml` written to {env_file}")

    # --- Update pyproject.toml using tomlkit ---
    if "project" not in toml_data:
        toml_data["project"] = {}

    toml_data["project"]["requires-python"] = python_constraint
    toml_data["project"]["dependencies"] = sorted(pip_dependencies)

    # Optional: if using poetry, add via CLI too
    if use_poetry:
        # Write a first pass of pyproject.toml so Poetry sees correct version
        with open(poetry_file, "w", encoding="utf-8") as f:
            f.write(tomlkit.dumps(toml_data))

        print("Running poetry to add dependencies...")
        subprocess.run(
            ["poetry", "add"] + pip_dependencies, check=True, cwd=project_root
        )

        subprocess.run(["poetry", "lock"])

        try:
            result = subprocess.run(
                ["poetry", "self", "show", "plugins"],
                check=True,
                cwd=project_root,
                capture_output=True,
                text=True,
            )
            if "poetry-plugin-export" not in result.stdout:
                subprocess.run(
                    ["poetry", "self", "add", "poetry-plugin-export"],
                    check=True,
                    cwd=project_root,
                )
        except subprocess.CalledProcessError as e:
            print("Could not verify or install poetry-plugin-export:", e)

        subprocess.run(
            [
                "poetry",
                "export",
                "-f",
                "requirements.txt",
                "--without-hashes",
                "-o",
                "requirements-exact.txt",
            ],
            check=True,
            cwd=project_root,
        )
        print("Exact requirements exported to requirements-exact.txt")

    # Write final toml
    with open(poetry_file, "w", encoding="utf-8") as f:
        f.write(tomlkit.dumps(toml_data))
    print(f"`pyproject.toml` updated at {poetry_file}")


if __name__ == "__main__":
    main()
